# Generated by Django 5.1.7 on 2026-01-20 05:48

import hashlib
from django.db import migrations


def migrate_questions_to_question_bank(apps, schema_editor):
    """
    Migrate existing Question records to QuestionBank.
    
    This migration:
    1. Creates QuestionBank entries for unique questions (based on hash)
    2. Links legacy Question records to QuestionBank via question_bank FK
    3. Creates MockTestQuestion entries for questions that belong to tests
    
    This is idempotent - safe to run multiple times.
    """
    Question = apps.get_model('mocktest', 'Question')
    QuestionBank = apps.get_model('mocktest', 'QuestionBank')
    MockTestQuestion = apps.get_model('mocktest', 'MockTestQuestion')
    
    # Track processed hashes to avoid duplicates
    processed_hashes = {}
    questions_migrated = 0
    mocktest_questions_created = 0
    
    # Process all questions
    for question in Question.objects.select_related('exam', 'difficulty_level').iterator():
        # Skip if already migrated
        if question.question_bank_id:
            continue
        
        # Generate hash
        exam_id_str = str(question.exam_id) if question.exam_id else ''
        year_str = str(question.year) if question.year else ''
        hash_string = f"{question.text}{exam_id_str}{year_str}{question.subject}"
        question_hash = hashlib.sha256(hash_string.encode()).hexdigest()
        
        # Get or create QuestionBank entry
        if question_hash in processed_hashes:
            # Reuse existing QuestionBank
            question_bank = processed_hashes[question_hash]
        else:
            # Create new QuestionBank entry
            question_bank, created = QuestionBank.objects.get_or_create(
                question_hash=question_hash,
                defaults={
                    'question_type': question.question_type,
                    'text': question.text,
                    'subject': question.subject,
                    'exam_id': question.exam_id,
                    'year': question.year,
                    'option_a': question.option_a or '',
                    'option_b': question.option_b or '',
                    'option_c': question.option_c or '',
                    'option_d': question.option_d or '',
                    'correct_option': question.correct_option,
                    'difficulty_level_id': question.difficulty_level_id,
                    'topic': question.topic or '',
                    'explanation': question.explanation or '',
                    'marks': question.marks,
                    'negative_marks': question.negative_marks,
                    'is_active': True,
                }
            )
            processed_hashes[question_hash] = question_bank
        
        # Link Question to QuestionBank
        question.question_bank_id = question_bank.id
        question.save(update_fields=['question_bank_id'])
        questions_migrated += 1
        
        # Create MockTestQuestion entry if question belongs to a test
        if question.mock_test_id:
            # Check if MockTestQuestion already exists
            mtq_exists = MockTestQuestion.objects.filter(
                mock_test_id=question.mock_test_id,
                question_id=question_bank.id
            ).exists()
            
            if not mtq_exists:
                # Check if question_number is already taken
                existing_mtq = MockTestQuestion.objects.filter(
                    mock_test_id=question.mock_test_id,
                    question_number=question.question_number
                ).first()
                
                if existing_mtq:
                    # If number is taken but different question, skip
                    # (This handles edge cases where same question number exists)
                    pass
                else:
                    MockTestQuestion.objects.create(
                        mock_test_id=question.mock_test_id,
                        question_id=question_bank.id,
                        question_number=question.question_number
                    )
                    mocktest_questions_created += 1
    
    print(f"Migration completed: {questions_migrated} questions migrated, "
          f"{mocktest_questions_created} MockTestQuestion entries created")


def reverse_migration(apps, schema_editor):
    """
    Reverse migration - remove QuestionBank links and MockTestQuestion entries.
    
    Note: This does NOT delete QuestionBank entries, only removes the links.
    QuestionBank entries remain for potential future use.
    """
    Question = apps.get_model('mocktest', 'Question')
    MockTestQuestion = apps.get_model('mocktest', 'MockTestQuestion')
    
    # Remove MockTestQuestion entries
    MockTestQuestion.objects.all().delete()
    
    # Clear question_bank links
    Question.objects.update(question_bank_id=None)
    
    print("Reverse migration completed: QuestionBank links removed")


class Migration(migrations.Migration):

    dependencies = [
        ('mocktest', '0014_add_question_bank_models'),
    ]

    operations = [
        migrations.RunPython(
            migrate_questions_to_question_bank,
            reverse_code=reverse_migration
        ),
    ]
